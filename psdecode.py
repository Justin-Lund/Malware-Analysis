"""
Script Name: psdecode.py
Author: Justin Lund
Date created: 06/05/23
Last modified: 06/08/23
Version: 1.0.1

Purpose:
This script is designed to de-obfuscate Powershell code

Dependencies:
- pygments: Used for syntax-highlighted code, for ease of reading

Usage:
python3 psdecode.py -i obfuscated_powershell.ps1

This will provide you with an interactive menu:
0) Show code sample
1) De-obfuscate PowerShell re-ordering
2) Remove backticks
3) Re-concatenate strings
4) Undo aLtErNaTiNg cApS vAriAbLeS
s) Save code

0 will prompt you as to how many lines of code you want to print to screen.
This is used to check if deobfuscation techniques were successful.

The reason the options are separated and the process isn't 100% automated,
is that the order of techniques applied may need to be changed depending on the code.

Once satisfied with the output, press 's' to save it to a new file.
"""

import re
import argparse
from pygments import highlight
from pygments.lexers import PowerShellLexer
from pygments.formatters import TerminalFormatter


def deobfuscate_powershell_reorder(lines):
    charset = r"\w|\d|\n|\s|,|.|\-|=|/|:|#|_|{|}|\[|\]"
    regex_finder = r"\(\"([{\d+}]+)\"\s*-f\s*(['" + charset + "',]+)\)"
    regex_position = r"{(\d+)}"
    regex_content = r"'([" + charset + "]+)'"
    regex_placeholder = r"({#subs_\d+})"
    regex_char = r"\[char\](\d+)"
    regex_concat = r"\((('|\"[\w|\s|\$]+'|\"\+|.)+)\)"

    new_content = []
    for line in lines:
        content = line
        count_matches = 0
        occurrences = {}

        matches = re.finditer(regex_char, content, re.IGNORECASE)
        for _, word in enumerate(matches):
            total = word.group()
            letter = int(word.groups()[0], 10)
            content = content.replace(total, "'" + chr(letter) + "'")
            content = content.replace("`", "")

        while re.search(regex_finder, content, re.IGNORECASE):
            matches = re.finditer(regex_finder, content, re.IGNORECASE)
            for _, word in enumerate(matches):
                positions = re.findall(
                    regex_position,
                    word.groups()[0].replace("\n", "").strip(),
                    re.IGNORECASE,
                )
                contents = re.findall(
                    regex_content,
                    word.groups()[1].replace("\n", "").strip(),
                    re.IGNORECASE,
                )
                if len(positions) == len(contents):
                    out = ""
                    for p in positions:
                        if re.match(regex_placeholder, contents[int(p)]):
                            out += occurrences["'" + contents[int(p)] + "'"]
                        else:
                            out += contents[int(p)].strip()
                    placeholder = "'{#subs_" + str(count_matches) + "}'"
                    occurrences[placeholder] = out
                    content = content.replace(word.group(), placeholder)
                    count_matches += 1

        subs = re.finditer(regex_placeholder, content, re.IGNORECASE)
        for _, word in enumerate(subs):
            content = content.replace(
                "'" + word.group() + "'", occurrences["'" + word.group() + "'"]
            )
        new_content.append(content)

    return new_content


def remove_ticks(line):
    line = line[:-1].replace('`', '') + line[-1]
    return line

def concatenate(line):
    pattern = r"((['\"])([^\2]+)\2\s*\+\s*(['\"])([^\4]+)\4)"
    match = re.search(pattern, line)
    while match:
        full_string = match.group(3) + match.group(5)
        line = line.replace(match.group(), match.group(2) + full_string + match.group(2))
        match = re.search(pattern, line)
    return line

def normalize_variable_names(lines):
    normalized_lines = []
    for line in lines:
        matches = re.findall(r'\${([^}]*)}', line)
        for match in matches:
            line = line.replace(match, match.lower().capitalize())
        normalized_lines.append(line)
    return normalized_lines

def main():
    parser = argparse.ArgumentParser(description='De-obfuscates PowerShell scripts.')
    parser.add_argument('-i', '--input', help='The input PowerShell script file.')
    args = parser.parse_args()

    if args.input is None:
        print("No input file provided. Please provide an input file with the -i option.")
        return

    with open(args.input, 'r') as f:
        lines = f.readlines()

    while True:
        print()
        print("0) Show code sample")
        print("1) De-obfuscate PowerShell re-ordering")
        print("2) Remove backticks")
        print("3) Re-concatenate strings")
        print("4) Undo aLtErNaTiNg cApS vAriAbLeS")
        print("s) Save code")
        print("q) Quit")

        option = input("Choose an option: ").lower()

        if option == "0":
            num_lines = int(input("How many lines of the script would you like to print? "))
            code_to_print = ''.join(lines[:num_lines])
            print(highlight(code_to_print, PowerShellLexer(), TerminalFormatter()))

#            normal uncoloured output:
#            for line in lines[:num_lines]:
#                print(line, end='')

        elif option == "1":
            reordered_script = deobfuscate_powershell_reorder(lines)
            lines = deobfuscate_powershell_reorder(lines)
        elif option == "2":
            lines = [remove_ticks(line) for line in lines]
        elif option == "3":
            lines = [concatenate(line) for line in lines]
        elif option == "4":
            lines = normalize_variable_names(lines)
        elif option == "s":
            output_file = input("Enter the output file name: ")
            with open(output_file, 'w') as f:
                f.writelines(lines)
            break
        elif option == "q":
            break
        else:
            print("Invalid option, please try again.")

if __name__ == "__main__":
    main()
